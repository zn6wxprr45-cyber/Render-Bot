# -*- coding: utf-8 -*-
"""Telegram Bot с Webhook для Render

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1i7TWV_1PmIeRpQOpsGFw2_PnhqV6YakQ
"""

# -*- coding: utf-8 -*-
"""
Основной файл телеграмм-бота "Онлайн-Поликлиника"
для пациентов с постинсультным таламическим синдромом.

Этот бот использует python-telegram-bot и Firebase Firestore.
"""

import logging
import os
import json
import datetime
import asyncio
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, KeyboardButton
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    ConversationHandler,
    ContextTypes,
    filters,
)
import firebase_admin
from firebase_admin import credentials, firestore, auth

# --- Настройки для Webhook (Render) ---
# Получаем URL и PORT из переменных окружения Render
# Render автоматически устанавливает PORT, а WEBHOOK_URL нужно настроить
PORT = int(os.environ.get("PORT", 8080)) # Порт, который должен слушать Render
WEBHOOK_URL = os.environ.get("WEBHOOK_URL") # Полный URL-адрес вашего сервиса (например, https://my-bot-name.onrender.com)
RENDER_URL = os.environ.get("RENDER_EXTERNAL_URL") # Альтернативный способ получить внешний URL

# Если WEBHOOK_URL не установлен (например, в локальной среде),
# используем RENDER_EXTERNAL_URL, который Render предоставляет автоматически.
if not WEBHOOK_URL and RENDER_URL:
    WEBHOOK_URL = RENDER_URL
    logger.info(f"Используется WEBHOOK_URL: {WEBHOOK_URL}")
elif not WEBHOOK_URL:
    logger.warning("WEBHOOK_URL не установлен. Бот будет работать в режиме Polling (если запущен локально) или не сможет работать на Web Service (Render).")

# --- Глобальные переменные для Firebase (ОБЯЗАТЕЛЬНО) ---
# Эти переменные будут предоставлены средой выполнения.
# НЕ ВСТАВЛЯЙТЕ СЮДА СВОИ КЛЮЧИ!

# Глобальная переменная для ID приложения
appId = os.environ.get("__APP_ID", 'default-app-id') # Используем os.environ.get для получения глобальных переменных

# Глобальная переменная для конфигурации Firebase
# Мы ожидаем, что это будет СТРОКА в формате JSON.
firebase_config_str = os.environ.get("__FIREBASE_CONFIG", '{}')

# Глобальный клиент Firestore
db = None

# --- Настройка логирования ---
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- Константы для кнопок меню (на русском) ---
SURVEY_BTN = "Пройти ежедневный опрос"
INFO_BTN = "Информация о клинике"
EMERGENCY_BTN = "Срочная помощь"
FEEDBACK_BTN = "Обратная связь"
ILLNESS_BTN = "О заболевании"
CANCEL_BTN = "Отмена"

# --- Состояния для ConversationHandler (Опрос) ---
(
    Q1_PAIN_LEVEL,
    Q2_PAIN_TYPE,
    Q3_MEDICATION,
    Q4_SIDE_EFFECTS,
    Q5_COMMENTS,
) = range(5)

# --- Состояния для ConversationHandler (Обратная связь) ---
GET_FEEDBACK = range(5, 6)


def initialize_firebase():
    """
    Инициализирует Firebase Admin SDK, используя глобальные переменные.
    """
    global db, appId
    try:
        firebase_config = json.loads(firebase_config_str)

        # Проверяем, есть ли serviceAccountId в конфиге
        if 'serviceAccountId' not in firebase_config:
             logger.warning("Firebase config не содержит 'serviceAccountId'. Используется стандартный serviceAccountKey.json.")
             # Попытка инициализации из файла по умолчанию (если он есть в среде)
             cred = credentials.ApplicationDefault()
        else:
            # Используем конфигурацию из __firebase_config
             cred = credentials.Certificate(firebase_config)

        # Проверяем, не инициализировано ли приложение
        if not firebase_admin._apps:
            firebase_admin.initialize_app(cred)
            logger.info("Firebase Admin SDK инициализирован.")
        else:
            logger.info("Firebase Admin SDK уже был инициализирован.")

        db = firestore.client()

        # Устанавливаем уровень логирования Firestore (полезно для отладки)
        # В production можно убрать
        try:
            from google.cloud.firestore import client as firestore_client
            firestore_client.LOG.setLevel(logging.DEBUG)
        except ImportError:
            pass

        logger.info(f"Firebase App ID: {appId}")
        logger.info("Клиент Firestore успешно создан.")

    except json.JSONDecodeError:
        logger.error("Ошибка декодирования __firebase_config. Убедитесь, что это корректная JSON-строка.")
        db = None
    except Exception as e:
        logger.error(f"Ошибка при инициализации Firebase: {e}")
        db = None


async def get_user_id(update: Update) -> str | None:
    """
    Возвращает Telegram User ID в виде строки.
    Это будет использоваться как {userId} в пути Firestore.
    """
    if not update.message or not update.message.from_user:
        logger.warning("Не удалось получить user_id из update")
        return None
    return str(update.message.from_user.id)


def get_main_menu_keyboard() -> ReplyKeyboardMarkup:
    """
    Возвращает главную клавиатуру меню.
    """
    keyboard = [
        [KeyboardButton(SURVEY_BTN)],
        [KeyboardButton(ILLNESS_BTN), KeyboardButton(INFO_BTN)],
        [KeyboardButton(FEEDBACK_BTN), KeyboardButton(EMERGENCY_BTN)],
    ]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)


# --- Основные обработчики команд ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Обработчик команды /start.
    Приветствует пользователя, показывает главное меню и регистрирует
    ежедневное напоминание.
    """
    user = update.message.from_user
    user_id = await get_user_id(update)
    chat_id = update.message.chat_id

    logger.info(f"Пользователь {user.first_name} (ID: {user_id}) запустил бота.")

    await update.message.reply_html(
        rf"Здравствуйте, {user.first_name}!",
        reply_markup=get_main_menu_keyboard(),
    )
    await update.message.reply_text(
        "Я - бот-помощник онлайн-поликлиники для пациентов с постинсультным таламическим синдромом.\n\n"
        "Вы можете ежедневно проходить опрос о своем состоянии или получить полезную информацию, используя кнопки ниже."
    )

    if db and user_id:
        try:
            user_ref = db.collection(f"artifacts/{appId}/users/{user_id}").document("profile")
            user_data = {
                "telegram_id": user_id,
                "first_name": user.first_name,
                "last_name": user.last_name,
                "username": user.username,
                "last_seen": firestore.SERVER_TIMESTAMP,
            }
            # set(..., merge=True) обновит или создаст документ
            user_ref.set(user_data, merge=True)
            logger.info(f"Профиль пользователя {user_id} сохранен в Firestore.")
        except Exception as e:
            logger.error(f"Ошибка сохранения профиля {user_id} в Firestore: {e}")
            await update.message.reply_text("Не удалось сохранить ваш профиль. Некоторые функции могут быть недоступны.")

    # --- Настройка ежедневного напоминания ---
    if context.job_queue:
        job_name = f"daily_reminder_{chat_id}"
        current_jobs = context.job_queue.get_jobs_by_name(job_name)

        if not current_jobs:
            # Напоминание в 9:00 утра по времени сервера
            # В реальном приложении нужно учитывать часовой пояс пользователя
            daily_time = datetime.time(hour=9, minute=0, second=0)
            context.job_queue.run_daily(
                callback_reminder,
                time=daily_time,
                chat_id=chat_id,
                name=job_name,
            )
            logger.info(f"Ежедневное напоминание установлено для chat_id: {chat_id}")
    else:
        logger.warning("JobQueue не доступен. Напоминания не будут установлены.")

    return ConversationHandler.END


async def callback_reminder(context: ContextTypes.DEFAULT_TYPE):
    """
    Функция, отправляющая ежедневное напоминание.
    """
    job = context.job
    await context.bot.send_message(
        chat_id=job.chat_id,
        text="Доброе утро! ☀️\n\nНапоминаем о необходимости пройти ежедневный опрос о Вашем самочувствии.",
        reply_markup=get_main_menu_keyboard(),
    )


# --- Обработчики статической информации ---

async def show_illness_info(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Показывает информационный листок о болезни.
    (Текст нужно будет дополнить реальной информацией)
    """
    logger.info(f"Пользователь {await get_user_id(update)} запросил 'О заболевании'")
    text = (
        "ℹ️ **О постинсультном таламическом синдроме (синдром Дежерина-Русси)**\n\n"
        "Это хроническое болевое состояние, которое может развиться после инсульта, повредившего таламус - часть мозга, отвечающую за обработку сенсорной информации.\n\n"
        "**Основные симптомы:**\n"
        "• Часто интенсивная, жгучая или ноющая боль на стороне тела, противоположной очагу инсульта.\n"
        "• Повышенная чувствительность к прикосновениям (аллодиния) или температурным изменениям.\n"
        "• Ощущение онемения, покалывания.\n\n"
        "**Течение заболевания:**\n"
        "Симптомы могут появиться как сразу после инсульта, так и спустя недели или месяцы. Боль обычно носит постоянный характер и плохо поддается лечению обычными анальгетиками.\n\n"
        "**Важно:**\n"
        "Регулярное наблюдение и точное описание вашего состояния (уровень боли, принимаемые лекарства, побочные эффекты) критически важны для подбора эффективной терапии. "
        "Пожалуйста, заполняйте ежедневный опросник максимально подробно."
    )
    await update.message.reply_text(text, parse_mode='Markdown')


async def show_info(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Показывает информацию о режиме работы.
    """
    logger.info(f"Пользователь {await get_user_id(update)} запросил 'Информация о клинике'")
    text = (
        "**Режим работы нашей онлайн-поликлиники:**\n\n"
        "• **Сбор данных (через бота):** Круглосуточно, 24/7.\n"
        "• **Анализ данных врачом:** Ваши анкеты анализируются лечащим врачом в будние дни с 9:00 до 17:00.\n"
        "• **Обратная связь:** Врач свяжется с вами (или вы получите ответ на ваш запрос) в течение 1 рабочего дня.\n\n"
        "❗️*Этот бот не предназначен для экстренных случаев.*"
    )
    await update.message.reply_text(text, parse_mode='Markdown')


async def show_emergency(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Показывает информацию о срочной помощи.
    """
    logger.info(f"Пользователь {await get_user_id(update)} запросил 'Срочная помощь'")
    text = (
        "🚨 **СРОЧНАЯ МЕДИЦИНСКАЯ ПОМОЩЬ** 🚨\n\n"
        "Этот бот **НЕ ЯВЛЯЕТСЯ** службой экстренной помощи.\n\n"
        "Если у вас возникло угрожающее жизни состояние (например, симптомы нового инсульта, сильное кровотечение, потеря сознания, невыносимая боль, не снимающаяся назначенными препаратами):\n\n"
        "1. **НЕМЕДЛЕННО** вызовите скорую помощь по телефону **103** или **112**.\n"
        "2. Сообщите диспетчеру о своих симптомах и о том, что у вас в анамнезе инсульт.\n\n"
        "Не тратьте время на ожидание ответа в боте в экстренной ситуации!"
    )
    await update.message.reply_text(text, parse_mode='Markdown')


# --- Логика Обратной связи (ConversationHandler) ---

async def feedback_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Начинает диалог сбора обратной связи.
    """
    logger.info(f"Пользователь {await get_user_id(update)} начал 'Обратная связь'")
    await update.message.reply_text(
        "Пожалуйста, напишите ваш вопрос, отзыв или предложение. Мы передадим его администратору.\n\n"
        "Для отмены введите /cancel или нажмите кнопку 'Отмена'.",
        reply_markup=ReplyKeyboardMarkup([[CANCEL_BTN]], resize_keyboard=True),
    )
    return GET_FEEDBACK


async def receive_feedback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Получает, сохраняет обратную связь и завершает диалог.
    """
    user_id = await get_user_id(update)
    feedback_text = update.message.text

    logger.info(f"Пользователь {user_id} оставил отзыв: {feedback_text[:50]}...")

    if db:
        try:
            feedback_data = {
                "user_id": user_id,
                "feedback_text": feedback_text,
                "timestamp": firestore.SERVER_TIMESTAMP,
            }
            # .add() создает документ с авто-ID
            db.collection(f"artifacts/{appId}/users/{user_id}/feedback").add(feedback_data)
            logger.info(f"Отзыв от {user_id} сохранен в Firestore.")

            await update.message.reply_text(
                "Спасибо! Ваше сообщение получено и будет рассмотрено.",
                reply_markup=get_main_menu_keyboard(),
            )
            return ConversationHandler.END

        except Exception as e:
            logger.error(f"Ошибка сохранения отзыва {user_id} в Firestore: {e}")
            await update.message.reply_text(
                "Произошла ошибка при сохранении вашего отзыва. Попробуйте позже.",
                reply_markup=get_main_menu_keyboard(),
            )
            return ConversationHandler.END
    else:
        logger.error("Firestore (db) не инициализирован. Отзыв не сохранен.")
        await update.message.reply_text(
            "Внутренняя ошибка сервера. Не удалось сохранить отзыв.",
            reply_markup=get_main_menu_keyboard(),
        )
        return ConversationHandler.END


# --- Логика Ежедневного Опроса (ConversationHandler) ---

async def survey_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Начинает ежедневный опрос. (Вопрос 1)
    """
    user_id = await get_user_id(update)
    logger.info(f"Пользователь {user_id} начал опрос.")

    # Очищаем данные предыдущего опроса, если они есть
    context.user_data["survey"] = {}

    keyboard = [
        ["0", "1", "2", "3", "4"],
        ["5", "6", "7", "8", "9", "10"],
        [CANCEL_BTN]
    ]
    await update.message.reply_text(
        "Начинаем ежедневный опрос.\n\n"
        "**Вопрос 1/5:**\n"
        "Оцените ваш *общий уровень боли* за последние 24 часа по шкале от 0 до 10:\n"
        "(где 0 - нет боли, 10 - невыносимая боль)",
        reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True),
        parse_mode='Markdown'
    )
    return Q1_PAIN_LEVEL


async def q1_pain_level(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Сохраняет ответ 1. Задает Вопрос 2.
    """
    answer = update.message.text
    if not answer.isdigit() or not (0 <= int(answer) <= 10):
        await update.message.reply_text("Пожалуйста, выберите число от 0 до 10.")
        return Q1_PAIN_LEVEL

    context.user_data["survey"]["pain_level"] = int(answer)
    logger.info(f"Q1 (Pain Level): {answer}")

    keyboard = [
        ["Жгучая", "Колющая"],
        ["Ноющая", "Стреляющая"],
        ["Другое (опишу)"],
        [CANCEL_BTN]
    ]
    await update.message.reply_text(
        "**Вопрос 2/5:**\n"
        "Какой *характер* боли преобладал?",
        reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True),
        parse_mode='Markdown'
    )
    return Q2_PAIN_TYPE


async def q2_pain_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Сохраняет ответ 2. Задает Вопрос 3.
    """
    answer = update.message.text
    context.user_data["survey"]["pain_type"] = answer
    logger.info(f"Q2 (Pain Type): {answer}")

    await update.message.reply_text(
        "**Вопрос 3/5:**\n"
        "Какие *препараты* (включая обезболивающие) и в каких дозировках вы принимали за последние 24 часа?\n\n"
        "(Например: 'Прегабалин 150мг утром и вечером, Парацетамол 500мг днем')",
        reply_markup=ReplyKeyboardMarkup([[CANCEL_BTN]], resize_keyboard=True),
        parse_mode='Markdown'
    )
    return Q3_MEDICATION


async def q3_medication(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Сохраняет ответ 3. Задает Вопрос 4.
    """
    answer = update.message.text
    context.user_data["survey"]["medication"] = answer
    logger.info(f"Q3 (Medication): {answer}")

    keyboard = [
        ["Да", "Нет"],
        [CANCEL_BTN]
    ]
    await update.message.reply_text(
        "**Вопрос 4/5:**\n"
        "Заметили ли вы какие-либо *побочные эффекты* от лечения? (например: сонливость, головокружение, тошнота)\n\n"
        "Если да, опишите их. Если нет, нажмите 'Нет'.",
        reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True),
        parse_mode='Markdown'
    )
    return Q4_SIDE_EFFECTS


async def q4_side_effects(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Сохраняет ответ 4. Задает Вопрос 5.
    """
    answer = update.message.text
    context.user_data["survey"]["side_effects"] = answer
    logger.info(f"Q4 (Side Effects): {answer}")

    keyboard = [
        ["Все в порядке"],
        [CANCEL_BTN]
    ]
    await update.message.reply_text(
        "**Вопрос 5/5:**\n"
        "Есть ли у вас *дополнительные комментарии* или жалобы? (например: 'боль усилилась ночью', 'сон стал лучше')",
        reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True),
        parse_mode='Markdown'
    )
    return Q5_COMMENTS


async def q5_comments_and_save(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Сохраняет ответ 5. Сохраняет весь опрос в Firestore. Завершает диалог.
    """
    answer = update.message.text
    context.user_data["survey"]["comments"] = answer
    logger.info(f"Q5 (Comments): {answer}")

    user_id = await get_user_id(update)
    survey_data = context.user_data["survey"]

    # Добавляем серверное время
    survey_data["timestamp"] = firestore.SERVER_TIMESTAMP
    survey_data["user_id"] = user_id

    if db:
        try:
            # .add() создает новый документ с автоматическим ID в коллекции 'surveys'
            db.collection(f"artifacts/{appId}/users/{user_id}/surveys").add(survey_data)
            logger.info(f"Опрос для {user_id} успешно сохранен в Firestore.")

            await update.message.reply_text(
                "Спасибо! Ваш ежедневный опрос завершен.\n"
                "Данные переданы для анализа.",
                reply_markup=get_main_menu_keyboard(),
            )
        except Exception as e:
            logger.error(f"Ошибка сохранения опроса {user_id} в Firestore: {e}")
            await update.message.reply_text(
                "Произошла ошибка при сохранении вашего опроса. Попробуйте позже.",
                reply_markup=get_main_menu_keyboard(),
            )
    else:
        logger.error("Firestore (db) не инициализирован. Опрос не сохранен.")
        await update.message.reply_text(
            "Внутренняя ошибка сервера. Не удалось сохранить опрос.",
            reply_markup=get_main_menu_keyboard(),
        )

    # Очищаем user_data
    context.user_data.pop("survey", None)
    return ConversationHandler.END


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Отменяет текущий диалог (опрос или обратную связь).
    """
    user = update.message.from_user
    logger.info(f"Пользователь {user.first_name} отменил операцию.")
    await update.message.reply_text(
        "Действие отменено.", reply_markup=get_main_menu_keyboard()
    )

    # Очищаем временные данные, если они были
    context.user_data.pop("survey", None)

    return ConversationHandler.END


# --- Главная функция ---

def main():
    """
    Главная функция запуска бота.
    """
    # 1. Инициализация Firebase
    # (Выполняется синхронно при запуске)
    initialize_firebase()

    if not db:
        logger.critical("Не удалось инициализировать Firestore. Бот не может быть запущен.")
        return

    # 2. Получение токена бота
    # ВАЖНО: Токен должен быть установлен как переменная окружения
    BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN")
    if not BOT_TOKEN:
        logger.critical(
            "Не найдена переменная окружения TELEGRAM_BOT_TOKEN. "
            "Бот не может быть запущен. "
            "Пожалуйста, установите ее."
        )
        return

    logger.info("Токен бота найден. Запуск...")

    # 3. Создание приложения
    # Устанавливаем http_version 1.1 для совместимости с Render
    application = Application.builder().token(BOT_TOKEN).http_version("1.1").build()

    # --- Обработчик отмены (для всех диалогов) ---
    cancel_handler = CommandHandler("cancel", cancel)
    cancel_button_handler = MessageHandler(filters.Regex(f"^{CANCEL_BTN}$"), cancel)

    # --- Диалог Обратной Связи ---
    feedback_conv_handler = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex(f"^{FEEDBACK_BTN}$"), feedback_start)],
        states={
            GET_FEEDBACK: [MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex(f"^{CANCEL_BTN}$"), receive_feedback)],
        },
        fallbacks=[cancel_handler, cancel_button_handler],
    )

    # --- Диалог Ежедневного Опроса ---
    survey_conv_handler = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex(f"^{SURVEY_BTN}$"), survey_start)],
        states={
            Q1_PAIN_LEVEL: [MessageHandler(filters.Regex(r"^\d+$") & ~filters.COMMAND, q1_pain_level)],
            Q2_PAIN_TYPE: [MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex(f"^{CANCEL_BTN}$"), q2_pain_type)],
            Q3_MEDICATION: [MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex(f"^{CANCEL_BTN}$"), q3_medication)],
            Q4_SIDE_EFFECTS: [MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex(f"^{CANCEL_BTN}$"), q4_side_effects)],
            Q5_COMMENTS: [MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex(f"^{CANCEL_BTN}$"), q5_comments_and_save)],
        },
        fallbacks=[cancel_handler, cancel_button_handler],
    )

    # 4. Регистрация обработчиков
    application.add_handler(CommandHandler("start", start))

    # Добавляем диалоги
    application.add_handler(survey_conv_handler)
    application.add_handler(feedback_conv_handler)

    # Добавляем обработчики для кнопок-команд
    application.add_handler(MessageHandler(filters.Regex(f"^{ILLNESS_BTN}$"), show_illness_info))
    application.add_handler(MessageHandler(filters.Regex(f"^{INFO_BTN}$"), show_info))
    application.add_handler(MessageHandler(filters.Regex(f"^{EMERGENCY_BTN}$"), show_emergency))

    # Обработчик для любого другого текста (на случай, если пользователь просто пишет)
    async def other_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.message.reply_text(
            "Я не понял ваш запрос. Пожалуйста, используйте кнопки меню.",
            reply_markup=get_main_menu_keyboard()
        )
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, other_text))


    # 5. Запуск бота
    if WEBHOOK_URL:
        # Запуск в режиме Webhook (для Render Web Service)
        path = BOT_TOKEN # Используем токен как путь к вебхуку для безопасности
        # Full URL = WEBHOOK_URL / BOT_TOKEN
        application.run_webhook(
            listen="0.0.0.0",
            port=PORT,
            url_path=path,
            webhook_url=f"{WEBHOOK_URL}/{path}",
        )
        logger.info(f"Бот запущен в режиме Webhook на порту {PORT}, URL: {WEBHOOK_URL}/{path}")
    else:
        # Запуск в режиме Polling (для локального тестирования или Worker)
        logger.info("Бот запущен в режиме Polling...")
        application.run_polling()


if __name__ == "__main__":
    main()
