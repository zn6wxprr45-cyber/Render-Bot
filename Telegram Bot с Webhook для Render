# -*- coding: utf-8 -*-
"""Телеграмм-бот "Онлайн-Поликлиника"

Основной файл телеграмм-бота "Онлайн-Поликлиника"
для пациентов с постинсультным таламическим синдромом.

Этот бот использует python-telegram-bot и Firebase Firestore.
Развернут через Gunicorn + Webhook.
"""

import logging
import os
import json
import datetime
import asyncio
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, KeyboardButton
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    ConversationHandler,
    ContextTypes,
    filters,
)
import firebase_admin
from firebase_admin import credentials, firestore, auth
from google.cloud.firestore import client as firestore_client # Импорт для настройки логирования

# --- Глобальные переменные для Firebase (ОБЯЗАТЕЛЬНО) ---
# Эти переменные будут предоставлены средой выполнения.
# НЕ ВСТАВЛЯЙТЕ СЮДА СВОИ КЛЮЧИ!

# Глобальная переменная для ID приложения
appId = os.environ.get("CANVAS_APP_ID", 'default-app-id') # Используем переменную окружения, если доступна

# Глобальная переменная для конфигурации Firebase
# Мы ожидаем, что это будет СТРОКА в формате JSON.
firebase_config_str = os.environ.get("FIREBASE_CONFIG", '{}') # Используем переменную окружения, если доступна

# Глобальный клиент Firestore
db = None

# --- Настройка логирования ---
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- Константы для кнопок меню (на русском) ---
SURVEY_BTN = "Пройти ежедневный опрос"
INFO_BTN = "Информация о клинике"
EMERGENCY_BTN = "Срочная помощь"
FEEDBACK_BTN = "Обратная связь"
ILLNESS_BTN = "О заболевании"
CANCEL_BTN = "Отмена"

# --- Состояния для ConversationHandler (Опрос) ---
(
    Q1_PAIN_LEVEL,
    Q2_PAIN_TYPE,
    Q3_MEDICATION,
    Q4_SIDE_EFFECTS,
    Q5_COMMENTS,
) = range(5)

# --- Состояния для ConversationHandler (Обратная связь) ---
GET_FEEDBACK = range(5, 6)


def initialize_firebase():
    """
    Инициализирует Firebase Admin SDK, используя глобальные переменные.
    """
    global db, appId
    try:
        # Пытаемся получить APP_ID и CONFIG из переменных среды, если они не заданы напрямую
        appId = os.environ.get("CANVAS_APP_ID", 'default-app-id')
        firebase_config_str = os.environ.get("FIREBASE_CONFIG", '{}')
        
        firebase_config = json.loads(firebase_config_str)

        # Проверяем, есть ли serviceAccountId в конфиге
        if 'serviceAccountId' not in firebase_config and not os.environ.get("GOOGLE_APPLICATION_CREDENTIALS"):
             logger.warning("Firebase config не содержит 'serviceAccountId' и не найдено GOOGLE_APPLICATION_CREDENTIALS. Используется ApplicationDefault.")
             # Попытка инициализации из файла по умолчанию (если он есть в среде)
             cred = credentials.ApplicationDefault()
        else:
            # Используем конфигурацию из firebase_config или ApplicationDefault
             cred = credentials.Certificate(firebase_config)

        # Проверяем, не инициализировано ли приложение
        if not firebase_admin._apps:
            firebase_admin.initialize_app(cred)
            logger.info("Firebase Admin SDK инициализирован.")
        else:
            logger.info("Firebase Admin SDK уже был инициализирован.")

        db = firestore.client()

        # Устанавливаем уровень логирования Firestore (полезно для отладки)
        try:
            firestore_client.LOG.setLevel(logging.DEBUG)
        except Exception:
            pass # Если не удалось, игнорируем

        logger.info(f"Firebase App ID: {appId}")
        logger.info("Клиент Firestore успешно создан.")

    except json.JSONDecodeError:
        logger.error("Ошибка декодирования FIREBASE_CONFIG. Убедитесь, что это корректная JSON-строка.")
        db = None
    except Exception as e:
        logger.error(f"Ошибка при инициализации Firebase: {e}")
        db = None


async def get_user_id(update: Update) -> str | None:
    """
    Возвращает Telegram User ID в виде строки.
    Это будет использоваться как {userId} в пути Firestore.
    """
    if not update.message or not update.message.from_user:
        logger.warning("Не удалось получить user_id из update")
        return None
    return str(update.message.from_user.id)


def get_main_menu_keyboard() -> ReplyKeyboardMarkup:
    """
    Возвращает главную клавиатуру меню.
    """
    keyboard = [
        [KeyboardButton(SURVEY_BTN)],
        [KeyboardButton(ILLNESS_BTN), KeyboardButton(INFO_BTN)],
        [KeyboardButton(FEEDBACK_BTN), KeyboardButton(EMERGENCY_BTN)],
    ]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)


# --- Основные обработчики команд ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Обработчик команды /start.
    Приветствует пользователя, показывает главное меню и регистрирует
    ежедневное напоминание.
    """
    user = update.message.from_user
    user_id = await get_user_id(update)
    chat_id = update.message.chat_id

    logger.info(f"Пользователь {user.first_name} (ID: {user_id}) запустил бота.")

    await update.message.reply_html(
        rf"Здравствуйте, {user.first_name}!",
        reply_markup=get_main_menu_keyboard(),
    )
    await update.message.reply_text(
        "Я - бот-помощник онлайн-поликлиники для пациентов с постинсультным таламическим синдромом.\n\n"
        "Вы можете ежедневно проходить опрос о своем состоянии или получить полезную информацию, используя кнопки ниже."
    )

    if db and user_id:
        try:
            # Путь для профиля: /artifacts/{appId}/users/{userId}/profile
            user_ref = db.collection(f"artifacts/{appId}/users").document(user_id)
            user_data = {
                "telegram_id": user_id,
                "first_name": user.first_name,
                "last_name": user.last_name,
                "username": user.username,
                "last_seen": firestore.SERVER_TIMESTAMP,
            }
            # set(..., merge=True) обновит или создаст документ
            user_ref.set(user_data, merge=True)
            logger.info(f"Профиль пользователя {user_id} сохранен в Firestore.")
        except Exception as e:
            logger.error(f"Ошибка сохранения профиля {user_id} в Firestore: {e}")
            await update.message.reply_text("Не удалось сохранить ваш профиль. Некоторые функции могут быть недоступны.")

    # --- Настройка ежедневного напоминания ---
    # В режиме Webhook JobQueue не используется для постоянных напоминаний,
    # так как процесс может быть выключен между запросами.
    # Напоминания обычно настраиваются через внешний планировщик (Cron Job)
    # или отдельный процесс. Для простоты, пока оставим только для локального запуска/Polling.

    # Код для напоминаний удален, так как он неэффективен в Webhook-среде Render
    # if context.job_queue:
    #     job_name = f"daily_reminder_{chat_id}"
    #     current_jobs = context.job_queue.get_jobs_by_name(job_name)

    #     if not current_jobs:
    #         daily_time = datetime.time(hour=9, minute=0, second=0)
    #         context.job_queue.run_daily(
    #             callback_reminder,
    #             time=daily_time,
    #             chat_id=chat_id,
    #             name=job_name,
    #         )
    #         logger.info(f"Ежедневное напоминание установлено для chat_id: {chat_id}")
    # else:
    #     logger.warning("JobQueue не доступен. Напоминания не будут установлены (но это нормально для Webhook).")

    return ConversationHandler.END


# async def callback_reminder(context: ContextTypes.DEFAULT_TYPE):
#     """
#     Функция, отправляющая ежедневное напоминание. (Удалена, не используется в Webhook)
#     """
#     job = context.job
#     await context.bot.send_message(
#         chat_id=job.chat_id,
#         text="Доброе утро! ☀️\n\nНапоминаем о необходимости пройти ежедневный опрос о Вашем самочувствии.",
#         reply_markup=get_main_menu_keyboard(),
#     )


# --- Обработчики статической информации ---

async def show_illness_info(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Показывает информационный листок о болезни.
    """
    user_id = await get_user_id(update)
    logger.info(f"Пользователь {user_id} запросил 'О заболевании'")
    text = (
        "ℹ️ **О постинсультном таламическом синдроме (синдром Дежерина-Русси)**\n\n"
        "Это хроническое болевое состояние, которое может развиться после инсульта, повредившего таламус - часть мозга, отвечающую за обработку сенсорной информации.\n\n"
        "**Основные симптомы:**\n"
        "• Часто интенсивная, жгучая или ноющая боль на стороне тела, противоположной очагу инсульта.\n"
        "• Повышенная чувствительность к прикосновениям (аллодиния) или температурным изменениям.\n"
        "• Ощущение онемения, покалывания.\n\n"
        "**Течение заболевания:**\n"
        "Симптомы могут появиться как сразу после инсульта, так и спустя недели или месяцы. Боль обычно носит постоянный характер и плохо поддается лечению обычными анальгетиками.\n\n"
        "**Важно:**\n"
        "Регулярное наблюдение и точное описание вашего состояния (уровень боли, принимаемые лекарства, побочные эффекты) критически важны для подбора эффективной терапии. "
        "Пожалуйста, заполняйте ежедневный опросник максимально подробно."
    )
    await update.message.reply_text(text, parse_mode='Markdown')


async def show_info(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Показывает информацию о режиме работы.
    """
    user_id = await get_user_id(update)
    logger.info(f"Пользователь {user_id} запросил 'Информация о клинике'")
    text = (
        "**Режим работы нашей онлайн-поликлиники:**\n\n"
        "• **Сбор данных (через бота):** Круглосуточно, 24/7.\n"
        "• **Анализ данных врачом:** Ваши анкеты анализируются лечащим врачом в будние дни с 9:00 до 17:00.\n"
        "• **Обратная связь:** Врач свяжется с вами (или вы получите ответ на ваш запрос) в течение 1 рабочего дня.\n\n"
        "❗️*Этот бот не предназначен для экстренных случаев.*"
    )
    await update.message.reply_text(text, parse_mode='Markdown')


async def show_emergency(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Показывает информацию о срочной помощи.
    """
    user_id = await get_user_id(update)
    logger.info(f"Пользователь {user_id} запросил 'Срочная помощь'")
    text = (
        "🚨 **СРОЧНАЯ МЕДИЦИНСКАЯ ПОМОЩЬ** 🚨\n\n"
        "Этот бот **НЕ ЯВЛЯЕТСЯ** службой экстренной помощи.\n\n"
        "Если у вас возникло угрожающее жизни состояние (например, симптомы нового инсульта, сильное кровотечение, потеря сознания, невыносимая боль, не снимающаяся назначенными препаратами):\n\n"
        "1. **НЕМЕДЛЕННО** вызовите скорую помощь по телефону **103** или **112**.\n"
        "2. Сообщите диспетчеру о своих симптомах и о том, что у вас в анамнезе инсульт.\n\n"
        "Не тратьте время на ожидание ответа в боте в экстренной ситуации!"
    )
    await update.message.reply_text(text, parse_mode='Markdown')


# --- Логика Обратной связи (ConversationHandler) ---

async def feedback_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Начинает диалог сбора обратной связи.
    """
    logger.info(f"Пользователь {await get_user_id(update)} начал 'Обратная связь'")
    await update.message.reply_text(
        "Пожалуйста, напишите ваш вопрос, отзыв или предложение. Мы передадим его администратору.\n\n"
        "Для отмены введите /cancel или нажмите кнопку 'Отмена'.",
        reply_markup=ReplyKeyboardMarkup([[CANCEL_BTN]], resize_keyboard=True),
    )
    return GET_FEEDBACK


async def receive_feedback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Получает, сохраняет обратную связь и завершает диалог.
    """
    user_id = await get_user_id(update)
    feedback_text = update.message.text

    logger.info(f"Пользователь {user_id} оставил отзыв: {feedback_text[:50]}...")

    if db:
        try:
            feedback_data = {
                "user_id": user_id,
                "feedback_text": feedback_text,
                "timestamp": firestore.SERVER_TIMESTAMP,
            }
            # Путь для обратной связи: /artifacts/{appId}/users/{userId}/feedback
            db.collection(f"artifacts/{appId}/users/{user_id}/feedback").add(feedback_data)
            logger.info(f"Отзыв от {user_id} сохранен в Firestore.")

            await update.message.reply_text(
                "Спасибо! Ваше сообщение получено и будет рассмотрено.",
                reply_markup=get_main_menu_keyboard(),
            )
            return ConversationHandler.END

        except Exception as e:
            logger.error(f"Ошибка сохранения отзыва {user_id} в Firestore: {e}")
            await update.message.reply_text(
                "Произошла ошибка при сохранении вашего отзыва. Попробуйте позже.",
                reply_markup=get_main_menu_keyboard(),
            )
            return ConversationHandler.END
    else:
        logger.error("Firestore (db) не инициализирован. Отзыв не сохранен.")
        await update.message.reply_text(
            "Внутренняя ошибка сервера. Не удалось сохранить отзыв.",
            reply_markup=get_main_menu_keyboard(),
        )
        return ConversationHandler.END


# --- Логика Ежедневного Опроса (ConversationHandler) ---

async def survey_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Начинает ежедневный опрос. (Вопрос 1)
    """
    user_id = await get_user_id(update)
    logger.info(f"Пользователь {user_id} начал опрос.")

    # Очищаем данные предыдущего опроса, если они есть
    context.user_data["survey"] = {}

    keyboard = [
        ["0", "1", "2", "3", "4"],
        ["5", "6", "7", "8", "9", "10"],
        [CANCEL_BTN]
    ]
    await update.message.reply_text(
        "Начинаем ежедневный опрос.\n\n"
        "**Вопрос 1/5:**\n"
        "Оцените ваш *общий уровень боли* за последние 24 часа по шкале от 0 до 10:\n"
        "(где 0 - нет боли, 10 - невыносимая боль)",
        reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True),
        parse_mode='Markdown'
    )
    return Q1_PAIN_LEVEL


async def q1_pain_level(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Сохраняет ответ 1. Задает Вопрос 2.
    """
    answer = update.message.text
    if not answer.isdigit() or not (0 <= int(answer) <= 10):
        await update.message.reply_text("Пожалуйста, выберите число от 0 до 10.")
        return Q1_PAIN_LEVEL

    context.user_data["survey"]["pain_level"] = int(answer)
    logger.info(f"Q1 (Pain Level): {answer}")

    keyboard = [
        ["Жгучая", "Колющая"],
        ["Ноющая", "Стреляющая"],
        ["Другое (опишу)"],
        [CANCEL_BTN]
    ]
    await update.message.reply_text(
        "**Вопрос 2/5:**\n"
        "Какой *характер* боли преобладал?",
        reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True),
        parse_mode='Markdown'
    )
    return Q2_PAIN_TYPE


async def q2_pain_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Сохраняет ответ 2. Задает Вопрос 3.
    """
    answer = update.message.text
    context.user_data["survey"]["pain_type"] = answer
    logger.info(f"Q2 (Pain Type): {answer}")

    await update.message.reply_text(
        "**Вопрос 3/5:**\n"
        "Какие *препараты* (включая обезболивающие) и в каких дозировках вы принимали за последние 24 часа?\n\n"
        "(Например: 'Прегабалин 150мг утром и вечером, Парацетамол 500мг днем')",
        reply_markup=ReplyKeyboardMarkup([[CANCEL_BTN]], resize_keyboard=True),
        parse_mode='Markdown'
    )
    return Q3_MEDICATION


async def q3_medication(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Сохраняет ответ 3. Задает Вопрос 4.
    """
    answer = update.message.text
    context.user_data["survey"]["medication"] = answer
    logger.info(f"Q3 (Medication): {answer}")

    keyboard = [
        ["Да", "Нет"],
        [CANCEL_BTN]
    ]
    await update.message.reply_text(
        "**Вопрос 4/5:**\n"
        "Заметили ли вы какие-либо *побочные эффекты* от лечения? (например: сонливость, головокружение, тошнота)\n\n"
        "Если да, опишите их. Если нет, нажмите 'Нет'.",
        reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True),
        parse_mode='Markdown'
    )
    return Q4_SIDE_EFFECTS


async def q4_side_effects(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Сохраняет ответ 4. Задает Вопрос 5.
    """
    answer = update.message.text
    context.user_data["survey"]["side_effects"] = answer
    logger.info(f"Q4 (Side Effects): {answer}")

    keyboard = [
        ["Все в порядке"],
        [CANCEL_BTN]
    ]
    await update.message.reply_text(
        "**Вопрос 5/5:**\n"
        "Есть ли у вас *дополнительные комментарии* или жалобы? (например: 'боль усилилась ночью', 'сон стал лучше')",
        reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True),
        parse_mode='Markdown'
    )
    return Q5_COMMENTS


async def q5_comments_and_save(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Сохраняет ответ 5. Сохраняет весь опрос в Firestore. Завершает диалог.
    """
    answer = update.message.text
    context.user_data["survey"]["comments"] = answer
    logger.info(f"Q5 (Comments): {answer}")

    user_id = await get_user_id(update)
    survey_data = context.user_data["survey"]

    # Добавляем серверное время
    survey_data["timestamp"] = firestore.SERVER_TIMESTAMP
    survey_data["user_id"] = user_id

    if db:
        try:
            # Путь для опроса: /artifacts/{appId}/users/{userId}/surveys
            db.collection(f"artifacts/{appId}/users/{user_id}/surveys").add(survey_data)
            logger.info(f"Опрос для {user_id} успешно сохранен в Firestore.")

            await update.message.reply_text(
                "Спасибо! Ваш ежедневный опрос завершен.\n"
                "Данные переданы для анализа.",
                reply_markup=get_main_menu_keyboard(),
            )
        except Exception as e:
            logger.error(f"Ошибка сохранения опроса {user_id} в Firestore: {e}")
            await update.message.reply_text(
                "Произошла ошибка при сохранении вашего опроса. Попробуйте позже.",
                reply_markup=get_main_menu_keyboard(),
            )
    else:
        logger.error("Firestore (db) не инициализирован. Опрос не сохранен.")
        await update.message.reply_text(
            "Внутренняя ошибка сервера. Не удалось сохранить опрос.",
            reply_markup=get_main_menu_keyboard(),
        )

    # Очищаем user_data
    context.user_data.pop("survey", None)
    return ConversationHandler.END


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Отменяет текущий диалог (опрос или обратную связь).
    """
    user = update.message.from_user
    logger.info(f"Пользователь {user.first_name} отменил операцию.")
    await update.message.reply_text(
        "Действие отменено.", reply_markup=get_main_menu_keyboard()
    )

    # Очищаем временные данные, если они были
    context.user_data.pop("survey", None)

    return ConversationHandler.END


# --- Инициализация приложения и обработчиков (для Gunicorn/Webhook) ---

# 1. Инициализация Firebase
# (Выполняется синхронно при запуске)
initialize_firebase()

if not db:
    logger.critical("Не удалось инициализировать Firestore. Бот может работать некорректно.")


# 2. Получение токена бота
BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN")
if not BOT_TOKEN:
    logger.critical(
        "Не найдена переменная окружения TELEGRAM_BOT_TOKEN. "
        "Бот не может быть запущен. "
        "Пожалуйста, установите ее."
    )
    # Здесь можно добавить return, но для Webhook-приложения
    # Application.builder() просто не будет иметь токена, что приведет к ошибке ниже.


# 3. Создание Application
# Создаем application в глобальной области видимости, чтобы Gunicorn мог его найти
application = Application.builder().token(BOT_TOKEN).build()

# --- Обработчик отмены (для всех диалогов) ---
cancel_handler = CommandHandler("cancel", cancel)
cancel_button_handler = MessageHandler(filters.Regex(f"^{CANCEL_BTN}$"), cancel)

# --- Диалог Обратной Связи ---
feedback_conv_handler = ConversationHandler(
    entry_points=[MessageHandler(filters.Regex(f"^{FEEDBACK_BTN}$"), feedback_start)],
    states={
        GET_FEEDBACK: [MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex(f"^{CANCEL_BTN}$"), receive_feedback)],
    },
    fallbacks=[cancel_handler, cancel_button_handler],
)

# --- Диалог Ежедневного Опроса ---
survey_conv_handler = ConversationHandler(
    entry_points=[MessageHandler(filters.Regex(f"^{SURVEY_BTN}$"), survey_start)],
    states={
        Q1_PAIN_LEVEL: [MessageHandler(filters.Regex(r"^\d+$") & ~filters.COMMAND, q1_pain_level)],
        Q2_PAIN_TYPE: [MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex(f"^{CANCEL_BTN}$"), q2_pain_type)],
        Q3_MEDICATION: [MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex(f"^{CANCEL_BTN}$"), q3_medication)],
        Q4_SIDE_EFFECTS: [MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex(f"^{CANCEL_BTN}$"), q4_side_effects)],
        Q5_COMMENTS: [MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex(f"^{CANCEL_BTN}$"), q5_comments_and_save)],
    },
    fallbacks=[cancel_handler, cancel_button_handler],
)

# 4. Регистрация обработчиков
application.add_handler(CommandHandler("start", start))

# Добавляем диалоги
application.add_handler(survey_conv_handler)
application.add_handler(feedback_conv_handler)

# Добавляем обработчики для кнопок-команд
application.add_handler(MessageHandler(filters.Regex(f"^{ILLNESS_BTN}$"), show_illness_info))
application.add_handler(MessageHandler(filters.Regex(f"^{INFO_BTN}$"), show_info))
application.add_handler(MessageHandler(filters.Regex(f"^{EMERGENCY_BTN}$"), show_emergency))

# Обработчик для любого другого текста (на случай, если пользователь просто пишет)
async def other_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        "Я не понял ваш запрос. Пожалуйста, используйте кнопки меню.",
        reply_markup=get_main_menu_keyboard()
    )
application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, other_text))


# 5. Получение WSGI-обработчика для Gunicorn
# Приложение Render автоматически установит переменную окружения PORT.
# Нам нужно, чтобы application.run_webhook отвечал на запросы,
# но при запуске через Gunicorn нам нужен просто WSGI-обработчик.
# Этот код создает WSGI-интерфейс, который Gunicorn будет использовать.
application.post_init()
application.updater.bot.set_webhook(os.environ.get("WEBHOOK_URL")) # Устанавливаем Webhook, используя URL, предоставленный Render

if __name__ == "__main__":
    # Локальный запуск (если запуск не через Gunicorn)
    logger.info("Запуск в режиме Polling (локально)...")
    application.run_polling(poll_interval=1.0)
