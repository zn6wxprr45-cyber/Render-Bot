# -*- coding: utf-8 -*-

"""
Основной файл телеграмм-бота "Онлайн-Поликлиника"
для пациентов с постинсультным таламическим синдромом.

*** ЭТА ВЕРСИЯ ПРЕДНАЗНАЧЕНА ДЛЯ РАБОТЫ ЧЕРЕЗ WEBHOOK (Render/Gunicorn) ***
"""

import logging
import os
import json
import datetime
import asyncio
from telegram import Update, ReplyKeyboardMarkup, ReplyKeyboardRemove, KeyboardButton
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    ConversationHandler,
    ContextTypes,
    filters,
)
from telegram.constants import ParseMode
import firebase_admin
from firebase_admin import credentials, firestore, auth

# --- Настройка логирования ---
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- ГЛОБАЛЬНЫЕ КОНСТАНТЫ И ПЕРЕМЕННЫЕ ---

# Глобальная переменная для ID приложения (извлекается из окружения)
appId = os.environ.get("CANVAS_APP_ID", 'default-app-id')

# Глобальная переменная для конфигурации Firebase (извлекается из окружения)
firebase_config_str = os.environ.get("FIREBASE_CONFIG", '{}')

# Глобальный клиент Firestore
db = None

# --- Константы для кнопок меню (на русском) ---
SURVEY_BTN = "Пройти ежедневный опрос"
INFO_BTN = "Информация о клинике"
EMERGENCY_BTN = "Срочная помощь"
FEEDBACK_BTN = "Обратная связь"
ILLNESS_BTN = "О заболевании"
CANCEL_BTN = "Отмена"

# --- Состояния для ConversationHandler (Опрос) ---
(
    Q1_PAIN_LEVEL,
    Q2_PAIN_TYPE,
    Q3_MEDICATION,
    Q4_SIDE_EFFECTS,
    Q5_COMMENTS,
) = range(5)

# --- Состояния для ConversationHandler (Обратная связь) ---
GET_FEEDBACK = range(5, 6)


def initialize_firebase():
    """
    Инициализирует Firebase Admin SDK, используя глобальные переменные.
    """
    global db
    try:
        firebase_config = json.loads(firebase_config_str)

        # Используем конфигурацию, если она предоставлена
        if firebase_config and firebase_config.get('type') == 'service_account':
             cred = credentials.Certificate(firebase_config)
        else:
             # Попытка инициализации из ApplicationDefault (для сред, где это настроено)
             logger.warning("Firebase config не содержит ключа 'service_account'. Попытка использовать ApplicationDefault.")
             cred = credentials.ApplicationDefault()


        # Проверяем, не инициализировано ли приложение
        if not firebase_admin._apps:
            firebase_admin.initialize_app(cred)
            logger.info("Firebase Admin SDK инициализирован.")
        else:
            logger.info("Firebase Admin SDK уже был инициализирован.")

        db = firestore.client()
        logger.info(f"Firebase App ID: {appId}")
        logger.info("Клиент Firestore успешно создан.")

    except json.JSONDecodeError:
        logger.error("Ошибка декодирования FIREBASE_CONFIG. Убедитесь, что это корректная JSON-строка.")
        db = None
    except Exception as e:
        logger.error(f"Ошибка при инициализации Firebase: {e}")
        db = None


async def get_user_id(update: Update) -> str | None:
    """
    Возвращает Telegram User ID в виде строки.
    Это будет использоваться как {userId} в пути Firestore.
    """
    if not update.effective_user:
        logger.warning("Не удалось получить user_id из update")
        return None
    return str(update.effective_user.id)


def get_main_menu_keyboard() -> ReplyKeyboardMarkup:
    """
    Возвращает главную клавиатуру меню.
    """
    keyboard = [
        [KeyboardButton(SURVEY_BTN)],
        [KeyboardButton(ILLNESS_BTN), KeyboardButton(INFO_BTN)],
        [KeyboardButton(FEEDBACK_BTN), KeyboardButton(EMERGENCY_BTN)],
    ]
    return ReplyKeyboardMarkup(keyboard, resize_keyboard=True)


# --- Основные обработчики команд ---

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Обработчик команды /start.
    Приветствует пользователя, показывает главное меню и регистрирует
    ежедневное напоминание.
    """
    user = update.effective_user
    user_id = await get_user_id(update)
    chat_id = update.effective_chat.id

    logger.info(f"Пользователь {user.first_name} (ID: {user_id}) запустил бота.")

    await update.message.reply_html(
        rf"Здравствуйте, {user.first_name}!",
        reply_markup=get_main_menu_keyboard(),
    )
    await update.message.reply_text(
        "Я - бот-помощник онлайн-поликлиники для пациентов с постинсультным таламическим синдромом.\n\n"
        "Вы можете ежедневно проходить опрос о своем состоянии или получить полезную информацию, используя кнопки ниже."
    )

    if db and user_id:
        try:
            # Путь для профиля пользователя
            user_ref = db.collection(f"artifacts/{appId}/users/{user_id}").document("profile")
            user_data = {
                "telegram_id": user_id,
                "first_name": user.first_name,
                "last_name": user.last_name,
                "username": user.username,
                "last_seen": firestore.SERVER_TIMESTAMP,
            }
            # set(..., merge=True) обновит или создаст документ
            user_ref.set(user_data, merge=True)
            logger.info(f"Профиль пользователя {user_id} сохранен в Firestore.")
        except Exception as e:
            logger.error(f"Ошибка сохранения профиля {user_id} в Firestore: {e}")
            await update.message.reply_text("Не удалось сохранить ваш профиль. Некоторые функции могут быть недоступны.")

    # --- Настройка ежедневного напоминания (Работает только в режиме run_polling) ---
    # В режиме Webhook (Render/Gunicorn) job_queue не работает, т.к. процесс не живет постоянно.
    # Если вы хотите напоминания, нужно использовать внешний сервис (Cron job).
    # Мы оставляем этот код закомментированным или удаляем его в Webhook-версии,
    # т.к. он не будет работать на Render.

    # if context.job_queue:
    #     job_name = f"daily_reminder_{chat_id}"
    #     current_jobs = context.job_queue.get_jobs_by_name(job_name)
    #     ...
    # return ConversationHandler.END
    return ConversationHandler.END


# --- Обработчики статической информации ---

async def show_illness_info(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Показывает информационный листок о болезни.
    """
    logger.info(f"Пользователь {await get_user_id(update)} запросил 'О заболевании'")
    text = (
        "ℹ️ **О постинсультном таламическом синдроме (синдром Дежерина-Русси)**\n\n"
        "Это хроническое болевое состояние, которое может развиться после инсульта, повредившего таламус - часть мозга, отвечающую за обработку сенсорной информации.\n\n"
        "**Основные симптомы:**\n"
        "• Часто интенсивная, жгучая или ноющая боль на стороне тела, противоположной очагу инсульта.\n"
        "• Повышенная чувствительность к прикосновениям (аллодиния) или температурным изменениям.\n"
        "• Ощущение онемения, покалывания.\n\n"
        "**Течение заболевания:**\n"
        "Симптомы могут появиться как сразу после инсульта, так и спустя недели или месяцы. Боль обычно носит постоянный характер и плохо поддается лечению обычными анальгетиками.\n\n"
        "**Важно:**\n"
        "Регулярное наблюдение и точное описание вашего состояния (уровень боли, принимаемые лекарства, побочные эффекты) критически важны для подбора эффективной терапии. "
        "Пожалуйста, заполняйте ежедневный опросник максимально подробно."
    )
    await update.message.reply_text(text, parse_mode=ParseMode.MARKDOWN)


async def show_info(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Показывает информацию о режиме работы.
    """
    logger.info(f"Пользователь {await get_user_id(update)} запросил 'Информация о клинике'")
    text = (
        "**Режим работы нашей онлайн-поликлиники:**\n\n"
        "• **Сбор данных (через бота):** Круглосуточно, 24/7.\n"
        "• **Анализ данных врачом:** Ваши анкеты анализируются лечащим врачом в будние дни с 9:00 до 17:00.\n"
        "• **Обратная связь:** Врач свяжется с вами (или вы получите ответ на ваш запрос) в течение 1 рабочего дня.\n\n"
        "❗️*Этот бот не предназначен для экстренных случаев.*"
    )
    await update.message.reply_text(text, parse_mode=ParseMode.MARKDOWN)


async def show_emergency(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    Показывает информацию о срочной помощи.
    """
    logger.info(f"Пользователь {await get_user_id(update)} запросил 'Срочная помощь'")
    text = (
        "🚨 **СРОЧНАЯ МЕДИЦИНСКАЯ ПОМОЩЬ** 🚨\n\n"
        "Этот бот **НЕ ЯВЛЯЕТСЯ** службой экстренной помощи.\n\n"
        "Если у вас возникло угрожающее жизни состояние (например, симптомы нового инсульта, сильное кровотечение, потеря сознания, невыносимая боль, не снимающаяся назначенными препаратами):\n\n"
        "1. **НЕМЕДЛЕННО** вызовите скорую помощь по телефону **103** или **112**.\n"
        "2. Сообщите диспетчеру о своих симптомах и о том, что у вас в анамнезе инсульт.\n\n"
        "Не тратьте время на ожидание ответа в боте в экстренной ситуации!"
    )
    await update.message.reply_text(text, parse_mode=ParseMode.MARKDOWN)


# --- Логика Обратной связи (ConversationHandler) ---

async def feedback_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Начинает диалог сбора обратной связи.
    """
    logger.info(f"Пользователь {await get_user_id(update)} начал 'Обратная связь'")
    await update.message.reply_text(
        "Пожалуйста, напишите ваш вопрос, отзыв или предложение. Мы передадим его администратору.\n\n"
        "Для отмены введите /cancel или нажмите кнопку 'Отмена'.",
        reply_markup=ReplyKeyboardMarkup([[CANCEL_BTN]], resize_keyboard=True),
    )
    return GET_FEEDBACK


async def receive_feedback(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Получает, сохраняет обратную связь и завершает диалог.
    """
    user_id = await get_user_id(update)
    feedback_text = update.message.text

    logger.info(f"Пользователь {user_id} оставил отзыв: {feedback_text[:50]}...")

    if db:
        try:
            feedback_data = {
                "user_id": user_id,
                "feedback_text": feedback_text,
                "timestamp": firestore.SERVER_TIMESTAMP,
            }
            # .add() создает документ с авто-ID
            db.collection(f"artifacts/{appId}/users/{user_id}/feedback").add(feedback_data)
            logger.info(f"Отзыв от {user_id} сохранен в Firestore.")

            await update.message.reply_text(
                "Спасибо! Ваше сообщение получено и будет рассмотрено.",
                reply_markup=get_main_menu_keyboard(),
            )
            return ConversationHandler.END

        except Exception as e:
            logger.error(f"Ошибка сохранения отзыва {user_id} в Firestore: {e}")
            await update.message.reply_text(
                "Произошла ошибка при сохранении вашего отзыва. Попробуйте позже.",
                reply_markup=get_main_menu_keyboard(),
            )
            return ConversationHandler.END
    else:
        logger.error("Firestore (db) не инициализирован. Отзыв не сохранен.")
        await update.message.reply_text(
            "Внутренняя ошибка сервера. Не удалось сохранить отзыв.",
            reply_markup=get_main_menu_keyboard(),
        )
        return ConversationHandler.END


# --- Логика Ежедневного Опроса (ConversationHandler) ---

async def survey_start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Начинает ежедневный опрос. (Вопрос 1)
    """
    user_id = await get_user_id(update)
    logger.info(f"Пользователь {user_id} начал опрос.")

    # Очищаем данные предыдущего опроса, если они есть
    context.user_data["survey"] = {}

    keyboard = [
        ["0", "1", "2", "3", "4"],
        ["5", "6", "7", "8", "9", "10"],
        [CANCEL_BTN]
    ]
    await update.message.reply_text(
        "Начинаем ежедневный опрос.\n\n"
        "**Вопрос 1/5:**\n"
        "Оцените ваш *общий уровень боли* за последние 24 часа по шкале от 0 до 10:\n"
        "(где 0 - нет боли, 10 - невыносимая боль)",
        reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True),
        parse_mode=ParseMode.MARKDOWN
    )
    return Q1_PAIN_LEVEL


async def q1_pain_level(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Сохраняет ответ 1. Задает Вопрос 2.
    """
    answer = update.message.text
    if not answer.isdigit() or not (0 <= int(answer) <= 10):
        await update.message.reply_text("Пожалуйста, выберите число от 0 до 10.")
        return Q1_PAIN_LEVEL

    context.user_data["survey"]["pain_level"] = int(answer)
    logger.info(f"Q1 (Pain Level): {answer}")

    keyboard = [
        ["Жгучая", "Колющая"],
        ["Ноющая", "Стреляющая"],
        ["Другое (опишу)"],
        [CANCEL_BTN]
    ]
    await update.message.reply_text(
        "**Вопрос 2/5:**\n"
        "Какой *характер* боли преобладал?",
        reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True),
        parse_mode=ParseMode.MARKDOWN
    )
    return Q2_PAIN_TYPE


async def q2_pain_type(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Сохраняет ответ 2. Задает Вопрос 3.
    """
    answer = update.message.text
    context.user_data["survey"]["pain_type"] = answer
    logger.info(f"Q2 (Pain Type): {answer}")

    await update.message.reply_text(
        "**Вопрос 3/5:**\n"
        "Какие *препараты* (включая обезболивающие) и в каких дозировках вы принимали за последние 24 часа?\n\n"
        "(Например: 'Прегабалин 150мг утром и вечером, Парацетамол 500мг днем')",
        reply_markup=ReplyKeyboardMarkup([[CANCEL_BTN]], resize_keyboard=True),
        parse_mode=ParseMode.MARKDOWN
    )
    return Q3_MEDICATION


async def q3_medication(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Сохраняет ответ 3. Задает Вопрос 4.
    """
    answer = update.message.text
    context.user_data["survey"]["medication"] = answer
    logger.info(f"Q3 (Medication): {answer}")

    keyboard = [
        ["Да", "Нет"],
        [CANCEL_BTN]
    ]
    await update.message.reply_text(
        "**Вопрос 4/5:**\n"
        "Заметили ли вы какие-либо *побочные эффекты* от лечения? (например: сонливость, головокружение, тошнота)\n\n"
        "Если да, опишите их. Если нет, нажмите 'Нет'.",
        reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True),
        parse_mode=ParseMode.MARKDOWN
    )
    return Q4_SIDE_EFFECTS


async def q4_side_effects(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Сохраняет ответ 4. Задает Вопрос 5.
    """
    answer = update.message.text
    context.user_data["survey"]["side_effects"] = answer
    logger.info(f"Q4 (Side Effects): {answer}")

    keyboard = [
        ["Все в порядке"],
        [CANCEL_BTN]
    ]
    await update.message.reply_text(
        "**Вопрос 5/5:**\n"
        "Есть ли у вас *дополнительные комментарии* или жалобы? (например: 'боль усилилась ночью', 'сон стал лучше')",
        reply_markup=ReplyKeyboardMarkup(keyboard, resize_keyboard=True),
        parse_mode=ParseMode.MARKDOWN
    )
    return Q5_COMMENTS


async def q5_comments_and_save(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Сохраняет ответ 5. Сохраняет весь опрос в Firestore. Завершает диалог.
    """
    answer = update.message.text
    context.user_data["survey"]["comments"] = answer
    logger.info(f"Q5 (Comments): {answer}")

    user_id = await get_user_id(update)
    survey_data = context.user_data["survey"]

    # Добавляем серверное время
    survey_data["timestamp"] = firestore.SERVER_TIMESTAMP
    survey_data["user_id"] = user_id

    if db:
        try:
            # .add() создает новый документ с автоматическим ID в коллекции 'surveys'
            db.collection(f"artifacts/{appId}/users/{user_id}/surveys").add(survey_data)
            logger.info(f"Опрос для {user_id} успешно сохранен в Firestore.")

            await update.message.reply_text(
                "Спасибо! Ваш ежедневный опрос завершен.\n"
                "Данные переданы для анализа.",
                reply_markup=get_main_menu_keyboard(),
            )
        except Exception as e:
            logger.error(f"Ошибка сохранения опроса {user_id} в Firestore: {e}")
            await update.message.reply_text(
                "Произошла ошибка при сохранении вашего опроса. Попробуйте позже.",
                reply_markup=get_main_menu_keyboard(),
            )
    else:
        logger.error("Firestore (db) не инициализирован. Опрос не сохранен.")
        await update.message.reply_text(
            "Внутренняя ошибка сервера. Не удалось сохранить опрос.",
            reply_markup=get_main_menu_keyboard(),
        )

    # Очищаем user_data
    context.user_data.pop("survey", None)
    return ConversationHandler.END


async def cancel(update: Update, context: ContextTypes.DEFAULT_TYPE) -> int:
    """
    Отменяет текущий диалог (опрос или обратную связь).
    """
    user = update.effective_user
    logger.info(f"Пользователь {user.first_name} отменил операцию.")
    await update.message.reply_text(
        "Действие отменено.", reply_markup=get_main_menu_keyboard()
    )

    # Очищаем временные данные, если они были
    context.user_data.pop("survey", None)

    return ConversationHandler.END


# --- ГЛАВНАЯ ФУНКЦИЯ И КОНФИГУРАЦИЯ WEBHOOK ---

# Здесь мы создаем объект application, который нужен Gunicorn
# Переменная application должна быть глобальной или доступна для импорта
application = None

def setup_application():
    """
    Настраивает и регистрирует все обработчики, создает объект Application.
    """
    global application

    # 1. Инициализация Firebase
    initialize_firebase()
    if not db:
        logger.critical("Не удалось инициализировать Firestore. Бот не может быть запущен.")
        # Вместо return лучше бросить исключение, чтобы Gunicorn знал об ошибке
        raise RuntimeError("Firebase initialization failed.")

    # 2. Получение токена бота
    BOT_TOKEN = os.environ.get("TELEGRAM_BOT_TOKEN")
    if not BOT_TOKEN:
        logger.critical("Не найден TELEGRAM_BOT_TOKEN. Бот не может быть запущен.")
        raise RuntimeError("Missing TELEGRAM_BOT_TOKEN.")

    # 3. Создание приложения
    application = Application.builder().token(BOT_TOKEN).build()

    # --- Обработчик отмены (для всех диалогов) ---
    cancel_handler = CommandHandler("cancel", cancel)
    cancel_button_handler = MessageHandler(filters.Regex(f"^{CANCEL_BTN}$"), cancel)

    # --- Диалог Обратной Связи ---
    feedback_conv_handler = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex(f"^{FEEDBACK_BTN}$"), feedback_start)],
        states={
            GET_FEEDBACK: [MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex(f"^{CANCEL_BTN}$"), receive_feedback)],
        },
        fallbacks=[cancel_handler, cancel_button_handler],
    )

    # --- Диалог Ежедневного Опроса ---
    survey_conv_handler = ConversationHandler(
        entry_points=[MessageHandler(filters.Regex(f"^{SURVEY_BTN}$"), survey_start)],
        states={
            Q1_PAIN_LEVEL: [MessageHandler(filters.Regex(r"^\d+$") & ~filters.COMMAND, q1_pain_level)],
            Q2_PAIN_TYPE: [MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex(f"^{CANCEL_BTN}$"), q2_pain_type)],
            Q3_MEDICATION: [MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex(f"^{CANCEL_BTN}$"), q3_medication)],
            Q4_SIDE_EFFECTS: [MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex(f"^{CANCEL_BTN}$"), q4_side_effects)],
            Q5_COMMENTS: [MessageHandler(filters.TEXT & ~filters.COMMAND & ~filters.Regex(f"^{CANCEL_BTN}$"), q5_comments_and_save)],
        },
        fallbacks=[cancel_handler, cancel_button_handler],
    )

    # 4. Регистрация обработчиков
    application.add_handler(CommandHandler("start", start))

    # Добавляем диалоги
    application.add_handler(survey_conv_handler)
    application.add_handler(feedback_conv_handler)

    # Добавляем обработчики для кнопок-команд
    application.add_handler(MessageHandler(filters.Regex(f"^{ILLNESS_BTN}$"), show_illness_info))
    application.add_handler(MessageHandler(filters.Regex(f"^{INFO_BTN}$"), show_info))
    application.add_handler(MessageHandler(filters.Regex(f"^{EMERGENCY_BTN}$"), show_emergency))

    # Обработчик для любого другого текста (на случай, если пользователь просто пишет)
    async def other_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
        await update.message.reply_text(
            "Я не понял ваш запрос. Пожалуйста, используйте кнопки меню.",
            reply_markup=get_main_menu_keyboard()
        )
    application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, other_text))

    logger.info("Application handlers set up successfully.")
    return application

# Создаем приложение при старте Gunicorn
application = setup_application()


async def set_webhook_on_startup(app: Application):
    """
    Устанавливает Webhook при запуске, используя URL из переменных окружения.
    Это асинхронная операция, которая выполнится только один раз.
    """
    WEBHOOK_URL = os.environ.get("WEBHOOK_URL")
    if not WEBHOOK_URL:
        logger.warning("WEBHOOK_URL не установлен в переменных окружения. Webhook не будет настроен.")
        return

    # Render запускает Gunicorn на корневом URL, поэтому путь не нужен.
    # Если бы вы использовали ngrok, путь мог бы быть /telegram.
    webhook_url = WEBHOOK_URL

    try:
        # Установка Webhook
        await app.bot.set_webhook(url=webhook_url)
        logger.info(f"Webhook успешно установлен на URL: {webhook_url}")
    except Exception as e:
        logger.error(f"Не удалось установить Webhook: {e}")
        # В случае неудачи, можно попытаться выйти, но Gunicorn будет пытаться перезапустить

# Запускаем установку Webhook при первом запуске приложения
# Gunicorn запускает приложение, и нам нужно убедиться, что Webhook установлен.
# Мы можем использовать asyncio.run_coroutine_threadsafe или просто вызывать его
# в асинхронном контексте, что сложно с Gunicorn.

# Поскольку `python-telegram-bot` версии 20.x имеет встроенные методы
# для работы с Webhook и Gunicorn, мы можем использовать его.
# В Gunicorn `application` будет использоваться как WSGI/ASGI приложение.

# Чтобы выполнить `set_webhook`, нам нужно запустить асинхронный код.
# Мы можем добавить его как задачу при запуске Gunicorn.
# Но самый простой способ для однократной операции - это выполнить ее
# синхронно в главном потоке при инициализации Gunicorn, если это возможно.

import threading

def run_once_set_webhook():
    """Синхронно запускает установку Webhook."""
    try:
        asyncio.run(set_webhook_on_startup(application))
    except RuntimeError as e:
        # Это может случиться, если нет запущенного цикла событий
        logger.warning(f"Не удалось запустить set_webhook синхронно: {e}. Попробуем с новым циклом.")
        try:
            loop = asyncio.new_event_loop()
            asyncio.set_event_loop(loop)
            loop.run_until_complete(set_webhook_on_startup(application))
            loop.close()
        except Exception as inner_e:
            logger.error(f"Критическая ошибка при попытке установки Webhook: {inner_e}")

# Выполняем установку Webhook один раз при инициализации приложения
if os.environ.get("WEBHOOK_URL"):
    run_once_set_webhook()
else:
    logger.warning("WEBHOOK_URL не установлен. Webhook не настроен. Проверьте переменные окружения Render.")


# Главная точка входа для Gunicorn (application - это объект ASGI/WSGI)
# Gunicorn будет вызывать `application` для обработки каждого входящего запроса.

# Если вы хотите использовать этот файл, сохраните его как telegram_bot.py
# и убедитесь, что ваш Procfile_web содержит:
# web: gunicorn telegram_bot:application --workers 1 --bind 0.0.0.0:$PORT
